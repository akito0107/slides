(window.webpackJsonp=window.webpackJsonp||[]).push([[3],[,,,,,,,,,,,,function(e,t,a){e.exports=a.p+"2e30f8034ed0faf4a0e95f4341afc0cc.webp"},function(e,t,a){e.exports=a.p+"609618a4470ae547e130c9153a987707.webp"},,,function(e,t,a){a(17),a(45),e.exports=a(42)},,,,,,,,,,,,,,,,,,,function(e,t,a){var n={"./00-title.md":36,"./01-contents.md":37,"./02-introduction.md":38,"./04-catacli.mdx":39,"./05-variable-arguments.mdx":40,"./06-conclusion.md":41};function l(e){var t=r(e);return a(t)}function r(e){if(!a.o(n,e)){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}return n[e]}l.keys=function(){return Object.keys(n)},l.resolve=r,e.exports=l,l.id=35},function(e,t,a){"use strict";a.r(t),a.d(t,"slides",(function(){return i})),a.d(t,"fusumaProps",(function(){return s})),a.d(t,"default",(function(){return o}));var n=a(2),l=a.n(n),r=a(1);function c(){return(c=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])}return e}).apply(this,arguments)}function u(e,t){if(null==e)return{};var a,n,l=function(e,t){if(null==e)return{};var a,n,l={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(l[a]=e[a]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var i=[function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h1",null,"TypeScript製ライブラリと開発体験"),Object(r.a)("h2",null,"TS Meetup #3"))}],s=[{}],p={slides:i},b="wrapper";function o(e){var t=e.components,a=u(e,["components"]);return Object(r.a)(b,c({},p,a,{components:t,mdxType:"MDXLayout"}),Object(r.a)("h1",null,"TypeScript製ライブラリと開発体験"),Object(r.a)("h2",null,"TS Meetup #3"))}o.isMDXComponent=!0},function(e,t,a){"use strict";a.r(t),a.d(t,"slides",(function(){return i})),a.d(t,"fusumaProps",(function(){return s})),a.d(t,"default",(function(){return o}));var n=a(2),l=a.n(n),r=a(1);function c(){return(c=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])}return e}).apply(this,arguments)}function u(e,t){if(null==e)return{};var a,n,l=function(e,t){if(null==e)return{};var a,n,l={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(l[a]=e[a]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var i=[function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h2",null,"Contents"))}],s=[{contents:"true"}],p={slides:i},b="wrapper";function o(e){var t=e.components,a=u(e,["components"]);return Object(r.a)(b,c({},p,a,{components:t,mdxType:"MDXLayout"}),Object(r.a)("h2",null,"Contents"))}o.isMDXComponent=!0},function(e,t,a){"use strict";a.r(t),a.d(t,"slides",(function(){return i})),a.d(t,"fusumaProps",(function(){return s})),a.d(t,"default",(function(){return o}));var n=a(2),l=a.n(n),r=a(1);function c(e,t){if(null==e)return{};var a,n,l=function(e,t){if(null==e)return{};var a,n,l={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(l[a]=e[a]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}function u(){return(u=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])}return e}).apply(this,arguments)}var i=[function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h2",null,"はじめに"))},function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h2",null,"自己紹介"),Object(r.a)("ul",null,Object(r.a)("li",{parentName:"ul"},"伊藤　瑛（いとう　あきと）"),Object(r.a)("li",{parentName:"ul"},"@Akito0107 Twitter / Github"),Object(r.a)("li",{parentName:"ul"},"TypeScript / Go をよく書いています"),Object(r.a)("li",{parentName:"ul"},"メインはバックエンド"),Object(r.a)("li",{parentName:"ul"},"blogやってます=> ",Object(r.a)("a",u({parentName:"li"},{href:"https://blog.akito0107.dev/"}),"https://blog.akito0107.dev/"))))},function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h2",null,"TypeScript とわたし"),Object(r.a)("ul",null,Object(r.a)("li",{parentName:"ul"},"一番最初に触り始めたのは使い始めたのは 2016 年ごろ",Object(r.a)("ul",{parentName:"li"},Object(r.a)("li",{parentName:"ul"},"Node.js 製のサーバサイドアプリケーションの運用をしていた"),Object(r.a)("li",{parentName:"ul"},"Runtime Error に苦しめられる日々"),Object(r.a)("li",{parentName:"ul"},"当時の TypeScript は Third Party 製のライブラリが充実しておらず、余計辛かったので使うのを諦める"))),Object(r.a)("li",{parentName:"ul"},"Flow に行ったりしたが、2018 年の春頃から本格的に TypeScript を触り始める"),Object(r.a)("li",{parentName:"ul"},"TypeScript でツール・ライブラリを作るのが趣味"),Object(r.a)("li",{parentName:"ul"},"ライブラリ屋？")))},function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h2",null,"今日伝えたいこと"),Object(r.a)("ul",null,Object(r.a)("li",{parentName:"ul"},"TypeScriptの型推論を活用すると、どういったAPIが実現できるのか"),Object(r.a)("li",{parentName:"ul"},"実例ベースで型のトリックとともにいくつか紹介します"),Object(r.a)("li",{parentName:"ul"},"なにか 1 つでもヒントになれば幸いです！")))},function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h2",null,"まえおき"),Object(r.a)("ul",null,Object(r.a)("li",{parentName:"ul"},"型パズルがいくつか出てくる"),Object(r.a)("li",{parentName:"ul"},"こういうこともできるよ、という話"),Object(r.a)("li",{parentName:"ul"},Object(r.a)("strong",null,"すべての TS のコードでこういったことをしよう、という話ではない"))))},function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h2",null,"TypeScriptでLibraryを書くメリットはなにか"),Object(r.a)("ul",null,Object(r.a)("li",{parentName:"ul"},"Libraryを書く人",Object(r.a)("ul",{parentName:"li"},Object(r.a)("li",{parentName:"ul"},"型に守られるため堅牢性/メンテナンス性/etcが上がる"))),Object(r.a)("li",{parentName:"ul"},"Libraryを使う人",Object(r.a)("ul",{parentName:"li"},Object(r.a)("li",{parentName:"ul"},"(型が正しく提供されていれば)APIの仕様把握のコストが減る"),Object(r.a)("li",{parentName:"ul"},"IDEの補完による高いDX")))),Object(r.a)("h3",null,"TSでしかできないようなDXを実現してみたい"))}],s=[{sectionTitle:"はじめに"},{},{},{},{},{}],p={slides:i},b="wrapper";function o(e){var t=e.components,a=c(e,["components"]);return Object(r.a)(b,u({},p,a,{components:t,mdxType:"MDXLayout"}),Object(r.a)("h2",null,"はじめに"),Object(r.a)("hr",null),Object(r.a)("h2",null,"自己紹介"),Object(r.a)("ul",null,Object(r.a)("li",{parentName:"ul"},"伊藤　瑛（いとう　あきと）"),Object(r.a)("li",{parentName:"ul"},"@Akito0107 Twitter / Github"),Object(r.a)("li",{parentName:"ul"},"TypeScript / Go をよく書いています"),Object(r.a)("li",{parentName:"ul"},"メインはバックエンド"),Object(r.a)("li",{parentName:"ul"},"blogやってます=> ",Object(r.a)("a",u({parentName:"li"},{href:"https://blog.akito0107.dev/"}),"https://blog.akito0107.dev/"))),Object(r.a)("hr",null),Object(r.a)("h2",null,"TypeScript とわたし"),Object(r.a)("ul",null,Object(r.a)("li",{parentName:"ul"},"一番最初に触り始めたのは使い始めたのは 2016 年ごろ",Object(r.a)("ul",{parentName:"li"},Object(r.a)("li",{parentName:"ul"},"Node.js 製のサーバサイドアプリケーションの運用をしていた"),Object(r.a)("li",{parentName:"ul"},"Runtime Error に苦しめられる日々"),Object(r.a)("li",{parentName:"ul"},"当時の TypeScript は Third Party 製のライブラリが充実しておらず、余計辛かったので使うのを諦める"))),Object(r.a)("li",{parentName:"ul"},"Flow に行ったりしたが、2018 年の春頃から本格的に TypeScript を触り始める"),Object(r.a)("li",{parentName:"ul"},"TypeScript でツール・ライブラリを作るのが趣味"),Object(r.a)("li",{parentName:"ul"},"ライブラリ屋？")),Object(r.a)("hr",null),Object(r.a)("h2",null,"今日伝えたいこと"),Object(r.a)("ul",null,Object(r.a)("li",{parentName:"ul"},"TypeScriptの型推論を活用すると、どういったAPIが実現できるのか"),Object(r.a)("li",{parentName:"ul"},"実例ベースで型のトリックとともにいくつか紹介します"),Object(r.a)("li",{parentName:"ul"},"なにか 1 つでもヒントになれば幸いです！")),Object(r.a)("hr",null),Object(r.a)("h2",null,"まえおき"),Object(r.a)("ul",null,Object(r.a)("li",{parentName:"ul"},"型パズルがいくつか出てくる"),Object(r.a)("li",{parentName:"ul"},"こういうこともできるよ、という話"),Object(r.a)("li",{parentName:"ul"},Object(r.a)("strong",null,"すべての TS のコードでこういったことをしよう、という話ではない"))),Object(r.a)("hr",null),Object(r.a)("h2",null,"TypeScriptでLibraryを書くメリットはなにか"),Object(r.a)("ul",null,Object(r.a)("li",{parentName:"ul"},"Libraryを書く人",Object(r.a)("ul",{parentName:"li"},Object(r.a)("li",{parentName:"ul"},"型に守られるため堅牢性/メンテナンス性/etcが上がる"))),Object(r.a)("li",{parentName:"ul"},"Libraryを使う人",Object(r.a)("ul",{parentName:"li"},Object(r.a)("li",{parentName:"ul"},"(型が正しく提供されていれば)APIの仕様把握のコストが減る"),Object(r.a)("li",{parentName:"ul"},"IDEの補完による高いDX")))),Object(r.a)("h3",null,"TSでしかできないようなDXを実現してみたい"))}o.isMDXComponent=!0},function(e,t,a){"use strict";a.r(t),a.d(t,"slides",(function(){return s})),a.d(t,"fusumaProps",(function(){return p})),a.d(t,"default",(function(){return m}));var n=a(4),l=a(2),r=a.n(l),c=a(1);function u(e,t){if(null==e)return{};var a,n,l=function(e,t){if(null==e)return{};var a,n,l={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(l[a]=e[a]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}function i(){return(i=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])}return e}).apply(this,arguments)}var s=[function(e){return Object(c.a)(r.a.Fragment,null,Object(c.a)("h2",null,"command line parser catacliの紹介"))},function(e){return Object(c.a)(r.a.Fragment,null,Object(c.a)("h2",null,"catacli"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)("a",i({parentName:"li"},{href:"https://github.com/akito0107/catacli"}),"github")),Object(c.a)("li",{parentName:"ul"},"TypeScript向けに書いたCommand Line Parser(Node.jsでCLI書くときに使うやつ)",Object(c.a)("ul",{parentName:"li"},Object(c.a)("li",{parentName:"ul"},"commander.js, minimist, yargsなどと同じジャンル"))),Object(c.a)("li",{parentName:"ul"},"型推論がかなり強く効く"),Object(c.a)("li",{parentName:"ul"},Object(c.a)("a",i({parentName:"li"},{href:"https://speakerdeck.com/akito0107/typescriptfalsekomandorainpasa"}),"詳しくはこちら")),Object(c.a)("li",{parentName:"ul"},"(名前変えました)")))},function(e){return Object(c.a)(r.a.Fragment,null,Object(c.a)("h2",null,"motivation"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"commander.js のAPI(Githubより)")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-js"}),"const program = require('commander');\n\nprogram\n  .option('-d, --debug', 'output extra debugging')\n  .option('-s, --small', 'small pizza size')\n  .option('-p, --pizza-type <type>', 'flavour of pizza');\n\nprogram.parse(process.argv);\n\nif (program.debug) console.log(program.opts());\nif (program.small) console.log('- small pizza size');\nif (program.pizzaType) console.log(`- ${program.pizzaType}`);\n")),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"文字列で ",Object(c.a)("inlineCode",{parentName:"li"},"flag")," を定義していくスタイル"),Object(c.a)("li",{parentName:"ul"},"flagが増えたときや、subcommandとか増えだすと辛い")),Object(c.a)("h3",null,"flagを全部型推論させたい！！！"))},function(e){return Object(c.a)(r.a.Fragment,null,Object(c.a)("h2",null,"Demo"),Object(c.a)("p",null,Object(c.a)("a",i({parentName:"p"},{href:"https://www.typescriptlang.org/play/#code/JYWwDg9gTgLgBAbwLACg5xAQwNYFMBCEEANrpgHYBixmA5gDSrpZ4ByAriAEa5TV2M0GHLgDKMKMHK1+DJsLwBhCCCzkAJoPRRc69gGNcsrQrESptAIJRanXORgmWuAAoQAzsBjAI5TMWtbEHsYd0EAXzgAMygVOAAifUwYTH1iYHiAblRUAHoAKlQARgAuOHdzaTh0mF5-QCSGPABPQGsGQHUGQH0GCC4AK1x9GHrAFfjATQZAItTAB1NAOwZAaPU4VHzc1H1fCrguIlIKWTgAXlNCEjIqGloACniIMFCi+PpEeXZ3Olwy+I2jijhcAA9McFI8VQ4QAlNkUMtVvAuHt1ptjrIzgBteIAWlRV1C8QAumDIeR3EcAHTECDnLhEzHuIp4iEoFYE+DkTg8PinWHODjcXiIy7XdwAJjuDyE6lwUUw7GIMDKRXuuVycCaEHYcCS5DgYEw7nccDFEql8AAbv52LgTE8Xm9mdyoN8-gDcECUKDwQy1hVJNIdvtnOIvTJThcqQBmYXIIT+YDat6YYUKpUqtVfdxgfrAKJNOBR7VwM7uAAWEBgqILFHU0VOIMez1orwSnos9v+YEBwNpeUKKAFZUA33KAeEMptNJvVAOvKgEUGQBryoAohkAgAwzeqACBVAAhGI0A0QyTWaACuNAGtRTEW+LWUVOut9vDriI+WxOAjgNtZxnKlUDdA79KhcGLBZ57N9In9Fi8lSAAs8Rvu68DHnQgocueRhBlBtBhJ+MDfmyr7goe8ArKo5YciIyi4RoZwRugfjBG8vwtoCJhiu4+iSNcPjkG8SQpGkwBwMAuowE0ab0YxJYxMA9jqMQWY4WoYp2jAmx3PIRq8J4vhvAADES6m3Batb1vEniOnASIAPIuAAKgAkkZrCiNi2Y2Fp8iIWUiFhPIZYaKQUBlGcAD69xUiCewAHwiug6AFHAACaRkAKoAEpwIoRkALLJZYrAACJwAAMkZADi5mKHA5miHAAASACicUVXAB5COg7rEqS5zxIhn78qUCT+fylIdUSJrEGaYJwAmEDYNmGhceQUS8DoFa5lexxwLxabyA1qxNWSFxtVSPZde1oS9aEAr9aauDDaN414VIM1QHN2a6vevDLXxuBrWqG2kCSW2teyoZvN1h2hqdg3nZkI2KmNE0Vjds26A9T4Bi9q31RDB3uESmA2MB4MJlUOFgMApDfHd0DyOE7aYe+RHqMiaIYh1wr07tTNFAKYb3Gicac4W0AwDiYJAA"}),"playground")))},function(e){return Object(c.a)(r.a.Fragment,null,Object(c.a)("h2",null,"型のトリック"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"①: String Literalをkeyにしたobjectを返す型")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),'const booleanFlag = makeBooleanFlag("opts1", {\n  usage: "boolean example"\n});\n\nconst b = booleanFlag(["--opts"]);\n')),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"②: 可変長引数の型推論")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),"const flags = mergeFlag(booleanFlag, numberFlag, stringFlag);\n")))},function(e){return Object(c.a)(r.a.Fragment,null,Object(c.a)("h2",null,"①: String Literalをkeyにしたobjectを返す型"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"ユーザが引数に与えた文字列のpropを持ったobjectの型として推論させる")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),'// --test <number> のflagを定義したい\nconst f = makeNumberFlag("test");\n// resは { test: number; }として推論される\nconst res = f(["test", "123"])\n')))},function(e){return Object(c.a)(r.a.Fragment,null,Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"Flag(Parser)の型定義(抜粋)",Object(c.a)("ul",{parentName:"li"},Object(c.a)("li",{parentName:"ul"},Object(c.a)("inlineCode",{parentName:"li"},"type Flag")," はコマンドライン引数( ",Object(c.a)("inlineCode",{parentName:"li"},"process.argv")," )を受け取り、parseした結果を返す関数(の型定義)")))),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),"type Flag<T, N extends string> = (args: string[]) => ParseResult<T, N>;\ntype ParseResult<T, N extends string> = {\n  [key in N]: {\n    value?: T;\n  };\n};\n")),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"実際のFlagParserはこの型を利用して実装されている")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),"export type NumberFlag<N extends string> = Flag<number, N>;\n\nexport function makeNumberFlag<N extends string>(name: N): NumberFlag<N> {\n  return (args: string[]) => {\n      // ~ parserのlogicが入る ~\n    return {\n      [name]: { value: parseInt(v, 10) }\n    };\n  };\n}\n")),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"ポイントは",Object(c.a)("strong",null,"<N extends string",">"),"と",Object(c.a)("strong",null,"[key in N]"),"と",Object(c.a)("strong",null,"型のcapture"))))},function(e){return Object(c.a)(r.a.Fragment,null,Object(c.a)("h2",null,"TypeScriptのextends"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"特に型パラメータで使われた場合、継承というより、型の制約条件を表すイメージ(",Object(c.a)("a",i({parentName:"li"},{href:"https://www.typescriptlang.org/docs/handbook/generics.html"}),"参考"),")"),Object(c.a)("li",{parentName:"ul"},Object(c.a)("inlineCode",{parentName:"li"},"N extends string")," の ",Object(c.a)("inlineCode",{parentName:"li"},"N")," は ",Object(c.a)("inlineCode",{parentName:"li"},"string")," を継承した型というよりも、 ",Object(c.a)("inlineCode",{parentName:"li"},"string")," の型に包含される型という認識のほうが近い"),Object(c.a)("li",{parentName:"ul"},Object(c.a)("inlineCode",{parentName:"li"},"string literal type")," (javascriptのstringの値そのものの型)はstringに包含される")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),'type A<N extends string> = {};\n\ntype B = A<"test">; // OK\ntype C = A<"test1" | "test2">; // OK\ntype D = A<string>; // OK\ntype E = A<123>; // NG\n')),Object(c.a)("div",{className:"literal"},Object(c.a)(n.a,(t={src:a(12),mdxType:"Img"},u="Img",(l="mdxType")in t?Object.defineProperty(t,l,{value:u,enumerable:!0,configurable:!0,writable:!0}):t[l]=u,t))));var t,l,u},function(e){return Object(c.a)(r.a.Fragment,null,Object(c.a)("h2",null,"mapped types"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)("a",i({parentName:"li"},{href:"https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types"}),"参考")),Object(c.a)("li",{parentName:"ul"},Object(c.a)("inlineCode",{parentName:"li"},"for in")," に近い動きをする")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),'type M<N extends string> = {\n    [K in N]: string;\n}\n\ntype B = M<"test">; // { test: string; }として推論される\ntype C = M<"test1" | "test2">; // { test1: string; test2: string; }として推論される\ntype D = M<string>; // { [x: string]: string; }として推論される\n')))},function(e){return Object(c.a)(r.a.Fragment,null,Object(c.a)("h2",null,"型のcapture"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"TypeScriptの関数の型パラメータは引数の型をcaptureしてくれる",Object(c.a)("a",i({parentName:"li"},{href:"https://www.typescriptlang.org/docs/handbook/generics.html#hello-world-of-generics"}),"参考")),Object(c.a)("li",{parentName:"ul"},Object(c.a)("inlineCode",{parentName:"li"},"type argument inference"))),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),'function capture<N>(a: N): N {\n    // 割愛\n}\n\nconst t = capture("test") // t = "test" (literal type) として推論される\n\nconst t2 = capture<string>("test") // t = string\n')))},function(e){return Object(c.a)(r.a.Fragment,null,Object(c.a)("h2",null,"全部組み合わせるとこうなる"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"引数をstring literal typeとして推論させることにより、引数で与えた文字列のpropを持ったobjectの型を定義することができる")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),"type Flag<T, N extends string> = (args: string[]) => ParseResult<T, N>;\ntype ParseResult<T, N extends string> = {\n  [key in N]: {\n    value?: T;\n  };\n};\n\nexport type NumberFlag<N extends string> = Flag<number, N>;\n\nexport function makeNumberFlag<N extends string>(name: N): NumberFlag<N> {\n  return (args: string[]) => {\n      // 割愛\n  };\n}\n")))},function(e){return Object(c.a)(r.a.Fragment,null,Object(c.a)("h2",null,"②: 可変長引数の型定義"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"任意のflag parserを組み合わせて、複数のflagをparseできるようにしたい"),Object(c.a)("li",{parentName:"ul"},Object(c.a)("inlineCode",{parentName:"li"},"mergeFlag")," の型定義について")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),'const argv = ["--test", "test", "--test2", "test2"]\n\nconst f1 = makeStringFlag("test") // (arg: string[]) => ({test: string;});\nconst f2 = makeStringFlag("test2") // (arg: string[]) => ({test2: string;}):\n\nconst merged = mergeFlag(f1, f2) // (args: string[]) => ({test: string; test2: string;});\n\nconst res = merged(argv); // {test: string; test2: string; }と推論させたい\n')))},function(e){return Object(c.a)(r.a.Fragment,null,Object(c.a)("h2",null,"引数が2個の場合"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"任意の関数を2つうけとり、返り値を合成して返す関数"),Object(c.a)("li",{parentName:"ul"},"それぞれの関数の返り値を型パラメータで受け取り,  ",Object(c.a)("inlineCode",{parentName:"li"},"intersection type")," を用いる")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),'function mergeFunction<R1, R2>(f1: (x: any) => R1, f2: (x: any) => R2): (x: any)  => R1 & R2 {\n    // 割愛\n}\n\nconst f1 = () => ({test: "test"});\nconst f2 = () => ({test2: "test2"});\n\nconst fm = mergeFunction(f1, f2); // (x: any) => ({test: "test"} & {test2: "test2"}) として推論\n')))},function(e){return Object(c.a)(r.a.Fragment,null,Object(c.a)("h2",null,"Flagで書いてみる"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"T1 / T2をそれぞれの引数のFlag(Parser)の型パラメータに渡す")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),'function merge2<T1, T1Name extends string, T2, T2Name extends string>(\n  t1: Flag<T1, T1Name>,\n  t2: Flag<T2, T2Name>\n): Flag<{ [key in T1Name]: T1 } & { [key in T2Name]: T2 }, T1Name | T2Name> {\n    // 割愛\n}\n\nconst f1 = makeStringFlag("test")\nconst f2 = makeStringFlag("test2")\nconst merged = merge2(f1, f2);\n\nconst res = merged(argv) // {test: string; test2: string;} として推論される\n')))},function(e){return Object(c.a)(r.a.Fragment,null,Object(c.a)("h2",null,"引数が3個の場合　"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"愚直にやるとこう")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),"function merge3<T1, T1Name extends string, T2, T2Name extends string, T3, T3Name extends string>(\n  t1: Flag<T1, T1Name>,\n  t2: Flag<T2, T2Name>,\n  t3: Flag<T3, T3Name>\n): Flag<{ [key in T1Name]: T1 } & { [key in T2Name]: T2 } & { [key in T3Name]: T3 }, T1Name | T2Name | T3Name> {\n    // 割愛\n}\n\n")))},function(e){return Object(c.a)(r.a.Fragment,null,Object(c.a)("h2",null,"引数がN個の場合"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"想定される引数の数だけ型定義を書いておく（あるいは生成する）のはひとつのベストプラクティス"),Object(c.a)("li",{parentName:"ul"},"本当に任意の数の引数を取るような関数の型定義を正しく書くのは ",Object(c.a)("strong",null,"すごく大変")," (あとで話します)")))},function(e){return Object(c.a)(r.a.Fragment,null,Object(c.a)("h2",null,"(参考)yargs"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"api styleの違い"),Object(c.a)("li",{parentName:"ul"},"method chain likeなapi")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),"import * as yargs from 'yargs';\n\nyargs.command('serve', \"Start the server.\", (argv) => {\n    /* ここの関数の返り値がそのままhandlerで推論されるようになる */\n    return argv.option('port', {\n        describe: \"Port to bind on\",\n        default: \"5000\",\n    }).option('verbose', {\n        alias: 'v',\n        default: false,\n    });\n}, (args) => {\n    /* argsの */\n    if (args.verbose) {\n        console.info(\"Starting the server...\");\n    }\n    (args.port);\n});\n")))},function(e){return Object(c.a)(r.a.Fragment,null,Object(c.a)("h2",null,"method chainの型定義"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"関数型チックにやろうとするよりはかなり型は書きやすい"),Object(c.a)("li",{parentName:"ul"},"N個の引数のときに苦しまなくても良い"),Object(c.a)("li",{parentName:"ul"},"(あまり使い勝手も変わらない)")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),'class FlagParser<T extends object> {\n    opts: T;\n\n    constructor(init: T) {\n        this.opts = init;\n    }\n\n    addStringFlag<N extends string>(name: N): FlagParser<T & {[key in N]: string;}> {\n        // 割愛\n        return <any>this\n    }\n\n}\n\nconst parser = new FlagParser({});\n\n// {test: string; test2: string}として推論される\nconst o = parser.addStringFlag("test").addStringFlag("test2").opts;\n')))},function(e){return Object(c.a)(r.a.Fragment,null,Object(c.a)("h2",null,"tree shakingとmethod chain"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)("strong",null,"(今回はNode.jsのCLIライブラリの話なので関係ない)")),Object(c.a)("li",{parentName:"ul"},"method chain styleのAPIはtree shakingが効きづらい傾向にある",Object(c.a)("ul",{parentName:"li"},Object(c.a)("li",{parentName:"ul"},"それぞれのmethodを独立してexportするのが難しい"),Object(c.a)("li",{parentName:"ul"},"side effectsの問題"))),Object(c.a)("li",{parentName:"ul"},"副作用のない関数を組み合わせて機能を作っていくほうがtree shaking的には有利")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),"export function stringFlag(){}\nexport function numberFlag(){} // numberFlagは使用されていなければbundle時に消える\n")))},function(e){return Object(c.a)(r.a.Fragment,null,Object(c.a)("h2",null,"可変長引数は諦めきれない"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"こうなっちゃう")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),"f(d, f(c, f(a, b)))\n")),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"こう書きたい")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),"f(d, c, b, a);\n")))}],p=[{sectionTitle:"catacliの紹介"},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{}],b={slides:s},o="wrapper";function m(e){var t=e.components,l=u(e,["components"]);return Object(c.a)(o,i({},b,l,{components:t,mdxType:"MDXLayout"}),Object(c.a)("h2",null,"command line parser catacliの紹介"),Object(c.a)("hr",null),Object(c.a)("h2",null,"catacli"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)("a",i({parentName:"li"},{href:"https://github.com/akito0107/catacli"}),"github")),Object(c.a)("li",{parentName:"ul"},"TypeScript向けに書いたCommand Line Parser(Node.jsでCLI書くときに使うやつ)",Object(c.a)("ul",{parentName:"li"},Object(c.a)("li",{parentName:"ul"},"commander.js, minimist, yargsなどと同じジャンル"))),Object(c.a)("li",{parentName:"ul"},"型推論がかなり強く効く"),Object(c.a)("li",{parentName:"ul"},Object(c.a)("a",i({parentName:"li"},{href:"https://speakerdeck.com/akito0107/typescriptfalsekomandorainpasa"}),"詳しくはこちら")),Object(c.a)("li",{parentName:"ul"},"(名前変えました)")),Object(c.a)("hr",null),Object(c.a)("h2",null,"motivation"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"commander.js のAPI(Githubより)")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-js"}),"const program = require('commander');\n\nprogram\n  .option('-d, --debug', 'output extra debugging')\n  .option('-s, --small', 'small pizza size')\n  .option('-p, --pizza-type <type>', 'flavour of pizza');\n\nprogram.parse(process.argv);\n\nif (program.debug) console.log(program.opts());\nif (program.small) console.log('- small pizza size');\nif (program.pizzaType) console.log(`- ${program.pizzaType}`);\n")),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"文字列で ",Object(c.a)("inlineCode",{parentName:"li"},"flag")," を定義していくスタイル"),Object(c.a)("li",{parentName:"ul"},"flagが増えたときや、subcommandとか増えだすと辛い")),Object(c.a)("h3",null,"flagを全部型推論させたい！！！"),Object(c.a)("hr",null),Object(c.a)("h2",null,"Demo"),Object(c.a)("p",null,Object(c.a)("a",i({parentName:"p"},{href:"https://www.typescriptlang.org/play/#code/JYWwDg9gTgLgBAbwLACg5xAQwNYFMBCEEANrpgHYBixmA5gDSrpZ4ByAriAEa5TV2M0GHLgDKMKMHK1+DJsLwBhCCCzkAJoPRRc69gGNcsrQrESptAIJRanXORgmWuAAoQAzsBjAI5TMWtbEHsYd0EAXzgAMygVOAAifUwYTH1iYHiAblRUAHoAKlQARgAuOHdzaTh0mF5-QCSGPABPQGsGQHUGQH0GCC4AK1x9GHrAFfjATQZAItTAB1NAOwZAaPU4VHzc1H1fCrguIlIKWTgAXlNCEjIqGloACniIMFCi+PpEeXZ3Olwy+I2jijhcAA9McFI8VQ4QAlNkUMtVvAuHt1ptjrIzgBteIAWlRV1C8QAumDIeR3EcAHTECDnLhEzHuIp4iEoFYE+DkTg8PinWHODjcXiIy7XdwAJjuDyE6lwUUw7GIMDKRXuuVycCaEHYcCS5DgYEw7nccDFEql8AAbv52LgTE8Xm9mdyoN8-gDcECUKDwQy1hVJNIdvtnOIvTJThcqQBmYXIIT+YDat6YYUKpUqtVfdxgfrAKJNOBR7VwM7uAAWEBgqILFHU0VOIMez1orwSnos9v+YEBwNpeUKKAFZUA33KAeEMptNJvVAOvKgEUGQBryoAohkAgAwzeqACBVAAhGI0A0QyTWaACuNAGtRTEW+LWUVOut9vDriI+WxOAjgNtZxnKlUDdA79KhcGLBZ57N9In9Fi8lSAAs8Rvu68DHnQgocueRhBlBtBhJ+MDfmyr7goe8ArKo5YciIyi4RoZwRugfjBG8vwtoCJhiu4+iSNcPjkG8SQpGkwBwMAuowE0ab0YxJYxMA9jqMQWY4WoYp2jAmx3PIRq8J4vhvAADES6m3Batb1vEniOnASIAPIuAAKgAkkZrCiNi2Y2Fp8iIWUiFhPIZYaKQUBlGcAD69xUiCewAHwiug6AFHAACaRkAKoAEpwIoRkALLJZYrAACJwAAMkZADi5mKHA5miHAAASACicUVXAB5COg7rEqS5zxIhn78qUCT+fylIdUSJrEGaYJwAmEDYNmGhceQUS8DoFa5lexxwLxabyA1qxNWSFxtVSPZde1oS9aEAr9aauDDaN414VIM1QHN2a6vevDLXxuBrWqG2kCSW2teyoZvN1h2hqdg3nZkI2KmNE0Vjds26A9T4Bi9q31RDB3uESmA2MB4MJlUOFgMApDfHd0DyOE7aYe+RHqMiaIYh1wr07tTNFAKYb3Gicac4W0AwDiYJAA"}),"playground")),Object(c.a)("hr",null),Object(c.a)("h2",null,"型のトリック"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"①: String Literalをkeyにしたobjectを返す型")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),'const booleanFlag = makeBooleanFlag("opts1", {\n  usage: "boolean example"\n});\n\nconst b = booleanFlag(["--opts"]);\n')),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"②: 可変長引数の型推論")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),"const flags = mergeFlag(booleanFlag, numberFlag, stringFlag);\n")),Object(c.a)("hr",null),Object(c.a)("h2",null,"①: String Literalをkeyにしたobjectを返す型"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"ユーザが引数に与えた文字列のpropを持ったobjectの型として推論させる")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),'// --test <number> のflagを定義したい\nconst f = makeNumberFlag("test");\n// resは { test: number; }として推論される\nconst res = f(["test", "123"])\n')),Object(c.a)("hr",null),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"Flag(Parser)の型定義(抜粋)",Object(c.a)("ul",{parentName:"li"},Object(c.a)("li",{parentName:"ul"},Object(c.a)("inlineCode",{parentName:"li"},"type Flag")," はコマンドライン引数( ",Object(c.a)("inlineCode",{parentName:"li"},"process.argv")," )を受け取り、parseした結果を返す関数(の型定義)")))),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),"type Flag<T, N extends string> = (args: string[]) => ParseResult<T, N>;\ntype ParseResult<T, N extends string> = {\n  [key in N]: {\n    value?: T;\n  };\n};\n")),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"実際のFlagParserはこの型を利用して実装されている")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),"export type NumberFlag<N extends string> = Flag<number, N>;\n\nexport function makeNumberFlag<N extends string>(name: N): NumberFlag<N> {\n  return (args: string[]) => {\n      // ~ parserのlogicが入る ~\n    return {\n      [name]: { value: parseInt(v, 10) }\n    };\n  };\n}\n")),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"ポイントは",Object(c.a)("strong",null,"<N extends string",">"),"と",Object(c.a)("strong",null,"[key in N]"),"と",Object(c.a)("strong",null,"型のcapture"))),Object(c.a)("hr",null),Object(c.a)("h2",null,"TypeScriptのextends"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"特に型パラメータで使われた場合、継承というより、型の制約条件を表すイメージ(",Object(c.a)("a",i({parentName:"li"},{href:"https://www.typescriptlang.org/docs/handbook/generics.html"}),"参考"),")"),Object(c.a)("li",{parentName:"ul"},Object(c.a)("inlineCode",{parentName:"li"},"N extends string")," の ",Object(c.a)("inlineCode",{parentName:"li"},"N")," は ",Object(c.a)("inlineCode",{parentName:"li"},"string")," を継承した型というよりも、 ",Object(c.a)("inlineCode",{parentName:"li"},"string")," の型に包含される型という認識のほうが近い"),Object(c.a)("li",{parentName:"ul"},Object(c.a)("inlineCode",{parentName:"li"},"string literal type")," (javascriptのstringの値そのものの型)はstringに包含される")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),'type A<N extends string> = {};\n\ntype B = A<"test">; // OK\ntype C = A<"test1" | "test2">; // OK\ntype D = A<string>; // OK\ntype E = A<123>; // NG\n')),Object(c.a)("div",{className:"literal"},Object(c.a)(n.a,{src:a(12),mdxType:"Img"})),Object(c.a)("hr",null),Object(c.a)("h2",null,"mapped types"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)("a",i({parentName:"li"},{href:"https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types"}),"参考")),Object(c.a)("li",{parentName:"ul"},Object(c.a)("inlineCode",{parentName:"li"},"for in")," に近い動きをする")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),'type M<N extends string> = {\n    [K in N]: string;\n}\n\ntype B = M<"test">; // { test: string; }として推論される\ntype C = M<"test1" | "test2">; // { test1: string; test2: string; }として推論される\ntype D = M<string>; // { [x: string]: string; }として推論される\n')),Object(c.a)("hr",null),Object(c.a)("h2",null,"型のcapture"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"TypeScriptの関数の型パラメータは引数の型をcaptureしてくれる",Object(c.a)("a",i({parentName:"li"},{href:"https://www.typescriptlang.org/docs/handbook/generics.html#hello-world-of-generics"}),"参考")),Object(c.a)("li",{parentName:"ul"},Object(c.a)("inlineCode",{parentName:"li"},"type argument inference"))),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),'function capture<N>(a: N): N {\n    // 割愛\n}\n\nconst t = capture("test") // t = "test" (literal type) として推論される\n\nconst t2 = capture<string>("test") // t = string\n')),Object(c.a)("hr",null),Object(c.a)("h2",null,"全部組み合わせるとこうなる"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"引数をstring literal typeとして推論させることにより、引数で与えた文字列のpropを持ったobjectの型を定義することができる")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),"type Flag<T, N extends string> = (args: string[]) => ParseResult<T, N>;\ntype ParseResult<T, N extends string> = {\n  [key in N]: {\n    value?: T;\n  };\n};\n\nexport type NumberFlag<N extends string> = Flag<number, N>;\n\nexport function makeNumberFlag<N extends string>(name: N): NumberFlag<N> {\n  return (args: string[]) => {\n      // 割愛\n  };\n}\n")),Object(c.a)("hr",null),Object(c.a)("h2",null,"②: 可変長引数の型定義"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"任意のflag parserを組み合わせて、複数のflagをparseできるようにしたい"),Object(c.a)("li",{parentName:"ul"},Object(c.a)("inlineCode",{parentName:"li"},"mergeFlag")," の型定義について")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),'const argv = ["--test", "test", "--test2", "test2"]\n\nconst f1 = makeStringFlag("test") // (arg: string[]) => ({test: string;});\nconst f2 = makeStringFlag("test2") // (arg: string[]) => ({test2: string;}):\n\nconst merged = mergeFlag(f1, f2) // (args: string[]) => ({test: string; test2: string;});\n\nconst res = merged(argv); // {test: string; test2: string; }と推論させたい\n')),Object(c.a)("hr",null),Object(c.a)("h2",null,"引数が2個の場合"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"任意の関数を2つうけとり、返り値を合成して返す関数"),Object(c.a)("li",{parentName:"ul"},"それぞれの関数の返り値を型パラメータで受け取り,  ",Object(c.a)("inlineCode",{parentName:"li"},"intersection type")," を用いる")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),'function mergeFunction<R1, R2>(f1: (x: any) => R1, f2: (x: any) => R2): (x: any)  => R1 & R2 {\n    // 割愛\n}\n\nconst f1 = () => ({test: "test"});\nconst f2 = () => ({test2: "test2"});\n\nconst fm = mergeFunction(f1, f2); // (x: any) => ({test: "test"} & {test2: "test2"}) として推論\n')),Object(c.a)("hr",null),Object(c.a)("h2",null,"Flagで書いてみる"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"T1 / T2をそれぞれの引数のFlag(Parser)の型パラメータに渡す")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),'function merge2<T1, T1Name extends string, T2, T2Name extends string>(\n  t1: Flag<T1, T1Name>,\n  t2: Flag<T2, T2Name>\n): Flag<{ [key in T1Name]: T1 } & { [key in T2Name]: T2 }, T1Name | T2Name> {\n    // 割愛\n}\n\nconst f1 = makeStringFlag("test")\nconst f2 = makeStringFlag("test2")\nconst merged = merge2(f1, f2);\n\nconst res = merged(argv) // {test: string; test2: string;} として推論される\n')),Object(c.a)("hr",null),Object(c.a)("h2",null,"引数が3個の場合　"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"愚直にやるとこう")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),"function merge3<T1, T1Name extends string, T2, T2Name extends string, T3, T3Name extends string>(\n  t1: Flag<T1, T1Name>,\n  t2: Flag<T2, T2Name>,\n  t3: Flag<T3, T3Name>\n): Flag<{ [key in T1Name]: T1 } & { [key in T2Name]: T2 } & { [key in T3Name]: T3 }, T1Name | T2Name | T3Name> {\n    // 割愛\n}\n\n")),Object(c.a)("hr",null),Object(c.a)("h2",null,"引数がN個の場合"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"想定される引数の数だけ型定義を書いておく（あるいは生成する）のはひとつのベストプラクティス"),Object(c.a)("li",{parentName:"ul"},"本当に任意の数の引数を取るような関数の型定義を正しく書くのは ",Object(c.a)("strong",null,"すごく大変")," (あとで話します)")),Object(c.a)("hr",null),Object(c.a)("h2",null,"(参考)yargs"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"api styleの違い"),Object(c.a)("li",{parentName:"ul"},"method chain likeなapi")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),"import * as yargs from 'yargs';\n\nyargs.command('serve', \"Start the server.\", (argv) => {\n    /* ここの関数の返り値がそのままhandlerで推論されるようになる */\n    return argv.option('port', {\n        describe: \"Port to bind on\",\n        default: \"5000\",\n    }).option('verbose', {\n        alias: 'v',\n        default: false,\n    });\n}, (args) => {\n    /* argsの */\n    if (args.verbose) {\n        console.info(\"Starting the server...\");\n    }\n    (args.port);\n});\n")),Object(c.a)("hr",null),Object(c.a)("h2",null,"method chainの型定義"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"関数型チックにやろうとするよりはかなり型は書きやすい"),Object(c.a)("li",{parentName:"ul"},"N個の引数のときに苦しまなくても良い"),Object(c.a)("li",{parentName:"ul"},"(あまり使い勝手も変わらない)")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),'class FlagParser<T extends object> {\n    opts: T;\n\n    constructor(init: T) {\n        this.opts = init;\n    }\n\n    addStringFlag<N extends string>(name: N): FlagParser<T & {[key in N]: string;}> {\n        // 割愛\n        return <any>this\n    }\n\n}\n\nconst parser = new FlagParser({});\n\n// {test: string; test2: string}として推論される\nconst o = parser.addStringFlag("test").addStringFlag("test2").opts;\n')),Object(c.a)("hr",null),Object(c.a)("h2",null,"tree shakingとmethod chain"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)("strong",null,"(今回はNode.jsのCLIライブラリの話なので関係ない)")),Object(c.a)("li",{parentName:"ul"},"method chain styleのAPIはtree shakingが効きづらい傾向にある",Object(c.a)("ul",{parentName:"li"},Object(c.a)("li",{parentName:"ul"},"それぞれのmethodを独立してexportするのが難しい"),Object(c.a)("li",{parentName:"ul"},"side effectsの問題"))),Object(c.a)("li",{parentName:"ul"},"副作用のない関数を組み合わせて機能を作っていくほうがtree shaking的には有利")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),"export function stringFlag(){}\nexport function numberFlag(){} // numberFlagは使用されていなければbundle時に消える\n")),Object(c.a)("hr",null),Object(c.a)("h2",null,"可変長引数は諦めきれない"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"こうなっちゃう")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),"f(d, f(c, f(a, b)))\n")),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"こう書きたい")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),"f(d, c, b, a);\n")))}m.isMDXComponent=!0},function(e,t,a){"use strict";a.r(t),a.d(t,"slides",(function(){return s})),a.d(t,"fusumaProps",(function(){return p})),a.d(t,"default",(function(){return m}));var n=a(4),l=a(2),r=a.n(l),c=a(1);function u(e,t){if(null==e)return{};var a,n,l=function(e,t){if(null==e)return{};var a,n,l={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(l[a]=e[a]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}function i(){return(i=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])}return e}).apply(this,arguments)}var s=[function(e){return Object(c.a)(r.a.Fragment,null,Object(c.a)("h2",null,"可変長引数の型推論"))},function(e){return Object(c.a)(r.a.Fragment,null,Object(c.a)("h2",null,"pipeNで考えてみる"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"任意の数の関数を受け取り、関数を返す関数")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),"// (a: number) => stringに推論されてほしい\nconst piped = pipeN(\n    (a: number) => (`${a}`),\n    (b: string) => ({key: b}),\n    (c: {key: string}) => (c.key),\n);\n")),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"( ",Object(c.a)("inlineCode",{parentName:"li"},"|>")," こんな演算子になるかもしれない)")))},function(e){return Object(c.a)(r.a.Fragment,null,Object(c.a)("h2",null,"可変長引数のハンドリング第一歩"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"可変長引数は",Object(c.a)("strong",null,"tuple"),"として扱える"),Object(c.a)("li",{parentName:"ul"},"TypeScriptには ",Object(c.a)("inlineCode",{parentName:"li"},"tuple")," という型がある ",Object(c.a)("a",i({parentName:"li"},{href:"https://www.typescriptlang.org/docs/handbook/basic-types.html#tuple"}),"参考")),Object(c.a)("li",{parentName:"ul"},"Arrayとの違いは、長さが固定であること、それぞれの要素の型が固定されていること")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),'let x: [string, number];\n\nx = ["hello", 10]; // OK\nx = [10, "hello"]; // Error\n')),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),"function<A extends Array<any>> tupleTest(...a: A): A {...}\n\ntupleTest(1, 2, 3, 4, 5) // [number, number, number, number, number]として推論される\n")))},function(e){return Object(c.a)(r.a.Fragment,null,Object(c.a)("h2",null,"Tuple操作のイディオムを覚えよう"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"Tuple操作の型のイディオムは探すと結構出てくる"),Object(c.a)("li",{parentName:"ul"},"外部ライブラリを頼るのが良さそう"),Object(c.a)("li",{parentName:"ul"},Object(c.a)("a",i({parentName:"li"},{href:"https://github.com/pirix-gh/ts-toolbelt"}),"ts-toolbelt"),"にだいたい揃ってる")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),"// Tupleの先頭の要素をとってくる\ntype Head<T extends Array<any>> = ((...args: T) => any) extends (x: infer Head, ...tail: any) => any ? Head : never;\n\ntype H = Head<[1, 2, 3, string]> // H = 1\n\n// Tupleの先頭以外をとってくる\ntype Tail<T extends Array<any>> = ((...args: T) => any) extends (x: any, ...tail: infer Tail) => any ? Tail : never;\n\ntype T = Tail<[1, 2, 3, string]> // T = [2, 3, string]\n\n// Tupleの一番最後の要素をとってくる\ntype Last<T extends any[]> = T[Exclude<keyof T, keyof Tail<T>>];\n\ntype L = Last<1, 2, 3, string]> // L = string\n")))},function(e){return Object(c.a)(r.a.Fragment,null,Object(c.a)("h2",null,"あとはくっつける！"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"(conditional typeを使っています)")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),"function pipeN<A extends Array<Fn<any, any>>>(...fns: A): \n  Head<A> extends (a: infer Arg) => any ? \n    Last<A> extends (a: any) => infer R ?  (a: Arg) => R : never : never {\n    // 実装は割愛\n}\n\nconst piped = pipeNT(\n    (a: number) => (`${a}`),\n    (b: string) => ({test: b})\n); // (a: number) => ({test: string}) として推論される\n")),Object(c.a)("h3",null,"ここまではできた"))},function(e){return Object(c.a)(r.a.Fragment,null,Object(c.a)("h2",null,"最高のpipeNを目指して"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"引数の関数同士に推論を効かせたい")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),"const piped = pipeNT(\n    (a: number) => (`${a}`), // 返り値の型はstring\n    (b: string) => ({test: b}) // 注釈なくても引数はstringとして推論してほしい\n    (c: {test: b}) => 123 // cも推論してほしい...\n);\n")),Object(c.a)("h3",null,"これがまだできていない"))},function(e){return Object(c.a)(r.a.Fragment,null,Object(c.a)("h2",null,"ramdaのpipe"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)("a",i({parentName:"li"},{href:"https://ramdajs.com/"}),"ramda.js"),"の ",Object(c.a)("inlineCode",{parentName:"li"},"pipe")," を見てみる"),Object(c.a)("li",{parentName:"ul"},"できてる")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),"import {pipe} from 'ramda'\n\nconst piped = pipe(\n  (a: number) => (`${a}`), // 返り値の型はstrig\n  (b) => {\n    return  {test: b} // bはstringとして推論\n  },\n  (c) => c.test // cは{test: b}として推論\n);\n")))},function(e){return Object(c.a)(r.a.Fragment,null,Object(c.a)("h2",null,"なぜなら"),Object(c.a)(n.a,(t={src:a(13),mdxType:"Img"},u="Img",(l="mdxType")in t?Object.defineProperty(t,l,{value:u,enumerable:!0,configurable:!0,writable:!0}):t[l]=u,t)));var t,l,u},function(e){return Object(c.a)(r.a.Fragment,null,Object(c.a)("h2",null,"結論"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"ある程度は頑張れるものの、やっぱり引数が想定される分だけ型定義を用意したほうが推論的にもよさそう"),Object(c.a)("li",{parentName:"ul"},"ramda / Rxjsはそういうアプローチ")))}],p=[{sectionTitle:"可変長引数の型推論"},{},{},{},{},{},{},{},{}],b={slides:s},o="wrapper";function m(e){var t=e.components,l=u(e,["components"]);return Object(c.a)(o,i({},b,l,{components:t,mdxType:"MDXLayout"}),Object(c.a)("h2",null,"可変長引数の型推論"),Object(c.a)("hr",null),Object(c.a)("h2",null,"pipeNで考えてみる"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"任意の数の関数を受け取り、関数を返す関数")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),"// (a: number) => stringに推論されてほしい\nconst piped = pipeN(\n    (a: number) => (`${a}`),\n    (b: string) => ({key: b}),\n    (c: {key: string}) => (c.key),\n);\n")),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"( ",Object(c.a)("inlineCode",{parentName:"li"},"|>")," こんな演算子になるかもしれない)")),Object(c.a)("hr",null),Object(c.a)("h2",null,"可変長引数のハンドリング第一歩"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"可変長引数は",Object(c.a)("strong",null,"tuple"),"として扱える"),Object(c.a)("li",{parentName:"ul"},"TypeScriptには ",Object(c.a)("inlineCode",{parentName:"li"},"tuple")," という型がある ",Object(c.a)("a",i({parentName:"li"},{href:"https://www.typescriptlang.org/docs/handbook/basic-types.html#tuple"}),"参考")),Object(c.a)("li",{parentName:"ul"},"Arrayとの違いは、長さが固定であること、それぞれの要素の型が固定されていること")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),'let x: [string, number];\n\nx = ["hello", 10]; // OK\nx = [10, "hello"]; // Error\n')),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),"function<A extends Array<any>> tupleTest(...a: A): A {...}\n\ntupleTest(1, 2, 3, 4, 5) // [number, number, number, number, number]として推論される\n")),Object(c.a)("hr",null),Object(c.a)("h2",null,"Tuple操作のイディオムを覚えよう"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"Tuple操作の型のイディオムは探すと結構出てくる"),Object(c.a)("li",{parentName:"ul"},"外部ライブラリを頼るのが良さそう"),Object(c.a)("li",{parentName:"ul"},Object(c.a)("a",i({parentName:"li"},{href:"https://github.com/pirix-gh/ts-toolbelt"}),"ts-toolbelt"),"にだいたい揃ってる")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),"// Tupleの先頭の要素をとってくる\ntype Head<T extends Array<any>> = ((...args: T) => any) extends (x: infer Head, ...tail: any) => any ? Head : never;\n\ntype H = Head<[1, 2, 3, string]> // H = 1\n\n// Tupleの先頭以外をとってくる\ntype Tail<T extends Array<any>> = ((...args: T) => any) extends (x: any, ...tail: infer Tail) => any ? Tail : never;\n\ntype T = Tail<[1, 2, 3, string]> // T = [2, 3, string]\n\n// Tupleの一番最後の要素をとってくる\ntype Last<T extends any[]> = T[Exclude<keyof T, keyof Tail<T>>];\n\ntype L = Last<1, 2, 3, string]> // L = string\n")),Object(c.a)("hr",null),Object(c.a)("h2",null,"あとはくっつける！"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"(conditional typeを使っています)")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),"function pipeN<A extends Array<Fn<any, any>>>(...fns: A): \n  Head<A> extends (a: infer Arg) => any ? \n    Last<A> extends (a: any) => infer R ?  (a: Arg) => R : never : never {\n    // 実装は割愛\n}\n\nconst piped = pipeNT(\n    (a: number) => (`${a}`),\n    (b: string) => ({test: b})\n); // (a: number) => ({test: string}) として推論される\n")),Object(c.a)("h3",null,"ここまではできた"),Object(c.a)("hr",null),Object(c.a)("h2",null,"最高のpipeNを目指して"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"引数の関数同士に推論を効かせたい")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),"const piped = pipeNT(\n    (a: number) => (`${a}`), // 返り値の型はstring\n    (b: string) => ({test: b}) // 注釈なくても引数はstringとして推論してほしい\n    (c: {test: b}) => 123 // cも推論してほしい...\n);\n")),Object(c.a)("h3",null,"これがまだできていない"),Object(c.a)("hr",null),Object(c.a)("h2",null,"ramdaのpipe"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},Object(c.a)("a",i({parentName:"li"},{href:"https://ramdajs.com/"}),"ramda.js"),"の ",Object(c.a)("inlineCode",{parentName:"li"},"pipe")," を見てみる"),Object(c.a)("li",{parentName:"ul"},"できてる")),Object(c.a)("pre",null,Object(c.a)("code",i({parentName:"pre"},{className:"language-ts"}),"import {pipe} from 'ramda'\n\nconst piped = pipe(\n  (a: number) => (`${a}`), // 返り値の型はstrig\n  (b) => {\n    return  {test: b} // bはstringとして推論\n  },\n  (c) => c.test // cは{test: b}として推論\n);\n")),Object(c.a)("hr",null),Object(c.a)("h2",null,"なぜなら"),Object(c.a)(n.a,{src:a(13),mdxType:"Img"}),Object(c.a)("hr",null),Object(c.a)("h2",null,"結論"),Object(c.a)("ul",null,Object(c.a)("li",{parentName:"ul"},"ある程度は頑張れるものの、やっぱり引数が想定される分だけ型定義を用意したほうが推論的にもよさそう"),Object(c.a)("li",{parentName:"ul"},"ramda / Rxjsはそういうアプローチ")))}m.isMDXComponent=!0},function(e,t,a){"use strict";a.r(t),a.d(t,"slides",(function(){return i})),a.d(t,"fusumaProps",(function(){return s})),a.d(t,"default",(function(){return o}));var n=a(2),l=a.n(n),r=a(1);function c(){return(c=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])}return e}).apply(this,arguments)}function u(e,t){if(null==e)return{};var a,n,l=function(e,t){if(null==e)return{};var a,n,l={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(l[a]=e[a]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var i=[function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h2",null,"終わりに"))},function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h2",null,"まとめ"),Object(r.a)("ul",null,Object(r.a)("li",{parentName:"ul"},"ライブラリを作るときに使ったTypeScriptの型推論のトリックをいくつか紹介しました"),Object(r.a)("li",{parentName:"ul"},"method chainと関数の合成"),Object(r.a)("li",{parentName:"ul"},"可変長引数の取り扱い方")))},function(e){return Object(r.a)(l.a.Fragment,null,Object(r.a)("h1",null,"ありがとうございました"))}],s=[{sectionTitle:"終わりに"},{},{}],p={slides:i},b="wrapper";function o(e){var t=e.components,a=u(e,["components"]);return Object(r.a)(b,c({},p,a,{components:t,mdxType:"MDXLayout"}),Object(r.a)("h2",null,"終わりに"),Object(r.a)("hr",null),Object(r.a)("h2",null,"まとめ"),Object(r.a)("ul",null,Object(r.a)("li",{parentName:"ul"},"ライブラリを作るときに使ったTypeScriptの型推論のトリックをいくつか紹介しました"),Object(r.a)("li",{parentName:"ul"},"method chainと関数の合成"),Object(r.a)("li",{parentName:"ul"},"可変長引数の取り扱い方")),Object(r.a)("hr",null),Object(r.a)("h1",null,"ありがとうございました"))}o.isMDXComponent=!0},,function(e,t,a){var n=a(44);"string"==typeof n&&(n=[[e.i,n,""]]);var l={insert:"head",singleton:!1};a(5)(n,l);n.locals&&(e.exports=n.locals)},function(e,t,a){}],[[16,5,6]],[0,8]]);